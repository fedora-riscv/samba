From e13b5ac52204bb8fb5569162d64a0e02111c86de Mon Sep 17 00:00:00 2001
From: Stefan Metzmacher <metze@samba.org>
Date: Wed, 27 Feb 2013 09:29:47 +0100
Subject: [PATCH 01/12] s3:nmbd: fix talloc_zero_array() check in
 nmbd_packets.c

Signed-off-by: Stefan Metzmacher <metze@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Fri Sep 23 18:08:21 CEST 2016 on sn-devel-144

BUG: https://bugzilla.samba.org/show_bug.cgi?id=12283

(cherry picked from commit 4470f01605a2f09b054550ee5a8f8d3b4ebc2098)
---
 source3/nmbd/nmbd_packets.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index b608354..c9a2dc7 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1724,7 +1724,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 	}
 
 	attrs = talloc_array(NULL, struct socket_attributes, count);
-	if (fds == NULL) {
+	if (attrs == NULL) {
 		DEBUG(1, ("create_listen_pollfds: malloc fail for attrs. "
 			  "size %d\n", count));
 		TALLOC_FREE(fds);
-- 
1.9.1


From 5822d51b20780248082b9885af55d01250a09d48 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:05:59 -0700
Subject: [PATCH 02/12] s3: nmbd: Add fd, triggered elements to struct
 socket_attributes.

Zero the attrs array on allocation, and mirror the fd's.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit d8ade0730797df22bfe28847e034eb6d116b0e00)
---
 source3/nmbd/nmbd_packets.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index c9a2dc7..619cc9a 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1683,6 +1683,8 @@ on subnet %s\n", rrec->response_id, inet_ntoa(rrec->packet->ip), subrec->subnet_
 struct socket_attributes {
 	enum packet_type type;
 	bool broadcast;
+	int fd;
+	bool triggered;
 };
 
 static bool create_listen_pollfds(struct pollfd **pfds,
@@ -1723,7 +1725,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		return true;
 	}
 
-	attrs = talloc_array(NULL, struct socket_attributes, count);
+	attrs = talloc_zero_array(NULL, struct socket_attributes, count);
 	if (attrs == NULL) {
 		DEBUG(1, ("create_listen_pollfds: malloc fail for attrs. "
 			  "size %d\n", count));
@@ -1734,11 +1736,13 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 	num = 0;
 
 	fds[num].fd = ClientNMB;
+	attrs[num].fd = ClientNMB;
 	attrs[num].type = NMB_PACKET;
 	attrs[num].broadcast = false;
 	num += 1;
 
 	fds[num].fd = ClientDGRAM;
+	attrs[num].fd = ClientDGRAM;
 	attrs[num].type = DGRAM_PACKET;
 	attrs[num].broadcast = false;
 	num += 1;
@@ -1747,6 +1751,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 
 		if (subrec->nmb_sock != -1) {
 			fds[num].fd = subrec->nmb_sock;
+			attrs[num].fd = subrec->nmb_sock;
 			attrs[num].type = NMB_PACKET;
 			attrs[num].broadcast = false;
 			num += 1;
@@ -1754,6 +1759,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 
 		if (subrec->nmb_bcast != -1) {
 			fds[num].fd = subrec->nmb_bcast;
+			attrs[num].fd = subrec->nmb_bcast;
 			attrs[num].type = NMB_PACKET;
 			attrs[num].broadcast = true;
 			num += 1;
@@ -1761,6 +1767,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 
 		if (subrec->dgram_sock != -1) {
 			fds[num].fd = subrec->dgram_sock;
+			attrs[num].fd = subrec->dgram_sock;
 			attrs[num].type = DGRAM_PACKET;
 			attrs[num].broadcast = false;
 			num += 1;
@@ -1768,6 +1775,7 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 
 		if (subrec->dgram_bcast != -1) {
 			fds[num].fd = subrec->dgram_bcast;
+			attrs[num].fd = subrec->dgram_bcast;
 			attrs[num].type = DGRAM_PACKET;
 			attrs[num].broadcast = true;
 			num += 1;
-- 
1.9.1


From ce0a36819b6d1fcf6c97a004227bdcb4a53143bc Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:12:43 -0700
Subject: [PATCH 03/12] s3: nmbd: Ensure attrs array mirrors fd's array for
 dns.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit 7f0717e751930cd5da029c1852ff9f61f95e40b7)
---
 source3/nmbd/nmbd_packets.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index 619cc9a..2648679 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1919,8 +1919,23 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 		if (fds == NULL) {
 			return true;
 		}
+		attrs = talloc_realloc(NULL,
+					attrs,
+					struct socket_attributes,
+					num_sockets + 1);
+		if (attrs == NULL) {
+			TALLOC_FREE(fds);
+			return true;
+		}
 		dns_pollidx = num_sockets;
 		fds[num_sockets].fd = dns_fd;
+		attrs[dns_pollidx].fd = dns_fd;
+		/*
+		 * dummy values, we only need
+		 * fd and triggered.
+		 */
+		attrs[dns_pollidx].type = NMB_PACKET;
+		attrs[dns_pollidx].broadcast = false;
 		num_sockets += 1;
 	}
 #endif
-- 
1.9.1


From 2d8baf18040b67f2d4504bded60cf03f65072cc5 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:16:58 -0700
Subject: [PATCH 04/12] s3: nmbd: Now attrs array mirrors fd's array use it in
 preference.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit 376e04656b6755d1a182430b39273a93495d00b2)
---
 source3/nmbd/nmbd_packets.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index 2648679..7321922 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -2004,7 +2004,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 			client_port = DGRAM_PORT;
 		}
 
-		packet = read_packet(fds[i].fd, packet_type);
+		packet = read_packet(attrs[i].fd, packet_type);
 		if (!packet) {
 			continue;
 		}
@@ -2014,7 +2014,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 		 * only is set then check it came from one of our local nets.
 		 */
 		if (lp_bind_interfaces_only() &&
-		    (fds[i].fd == client_fd) &&
+		    (attrs[i].fd == client_fd) &&
 		    (!is_local_net_v4(packet->ip))) {
 			DEBUG(7,("discarding %s packet sent to broadcast socket from %s:%d\n",
 				packet_name, inet_ntoa(packet->ip), packet->port));
@@ -2053,10 +2053,10 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 
 		if (attrs[i].broadcast) {
 			/* this is a broadcast socket */
-			packet->send_fd = fds[i-1].fd;
+			packet->send_fd = attrs[i-1].fd;
 		} else {
 			/* this is already a unicast socket */
-			packet->send_fd = fds[i].fd;
+			packet->send_fd = attrs[i].fd;
 		}
 
 		queue_packet(packet);
-- 
1.9.1


From 6ad7738fd892b2edd75dc699e962dd557ebcf1b2 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:18:37 -0700
Subject: [PATCH 05/12] s3: nmbd: Add (currently unused) timeout and fd
 handlers.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit cca25c8f75147873280464eaf2699ff449f609ad)
---
 source3/nmbd/nmbd_packets.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index 7321922..caef1db 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1872,6 +1872,32 @@ static void free_processed_packet_list(struct processed_packet **pp_processed_pa
 }
 
 /****************************************************************************
+ Timeout callback - just notice we timed out.
+***************************************************************************/
+
+static void nmbd_timeout_handler(struct tevent_context *ev,
+			struct tevent_timer *te,
+			struct timeval current_time,
+			void *private_data)
+{
+	bool *got_timeout = private_data;
+	*got_timeout = true;
+}
+
+/****************************************************************************
+ fd callback - remember the fd that triggered.
+***************************************************************************/
+
+static void nmbd_fd_handler(struct tevent_context *ev,
+				struct tevent_fd *fde,
+				uint16_t flags,
+				void *private_data)
+{
+	struct socket_attributes *attr = private_data;
+	attr->triggered = true;
+}
+
+/****************************************************************************
   Listens for NMB or DGRAM packets, and queues them.
   return True if the socket is dead
 ***************************************************************************/
-- 
1.9.1


From 01573b2d214a20819226908f3e3653a513e78c11 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:22:53 -0700
Subject: [PATCH 06/12] s3: nmbd: Add a talloc_stackframe().

We will use this to create real tevent timer and fd
events.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit 36b67729a6fc8518da71944db3fac6d9236b9348)
---
 source3/nmbd/nmbd_packets.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index caef1db..c0c4925 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1917,10 +1917,12 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	int dns_pollidx = -1;
 #endif
 	struct processed_packet *processed_packet_list = NULL;
+	TALLOC_CTX *frame = talloc_stackframe();
 
 	if ((fds == NULL) || rescan_listen_set) {
 		if (create_listen_pollfds(&fds, &attrs, &listen_number)) {
 			DEBUG(0,("listen_for_packets: Fatal error. unable to create listen set. Exiting.\n"));
+			TALLOC_FREE(frame);
 			return True;
 		}
 		rescan_listen_set = False;
@@ -1934,6 +1936,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 
 	fds = talloc_realloc(NULL, fds, struct pollfd, listen_number);
 	if (fds == NULL) {
+		TALLOC_FREE(frame);
 		return true;
 	}
 	num_sockets = listen_number;
@@ -1943,6 +1946,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	if (dns_fd != -1) {
 		fds = talloc_realloc(NULL, fds, struct pollfd, num_sockets+1);
 		if (fds == NULL) {
+			TALLOC_FREE(frame);
 			return true;
 		}
 		attrs = talloc_realloc(NULL,
@@ -1951,6 +1955,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 					num_sockets + 1);
 		if (attrs == NULL) {
 			TALLOC_FREE(fds);
+			TALLOC_FREE(frame);
 			return true;
 		}
 		dns_pollidx = num_sockets;
@@ -1972,6 +1977,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 
 	/* Process a signal and timer events now... */
 	if (run_events_poll(nmbd_event_context(), 0, NULL, 0)) {
+		TALLOC_FREE(frame);
 		return False;
 	}
 
@@ -1991,10 +1997,12 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	pollrtn = poll(fds, num_sockets, timeout);
 
 	if (run_events_poll(nmbd_event_context(), pollrtn, fds, num_sockets)) {
+		TALLOC_FREE(frame);
 		return False;
 	}
 
 	if (pollrtn == -1) {
+		TALLOC_FREE(frame);
 		return False;
 	}
 
@@ -2089,6 +2097,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	}
 
 	free_processed_packet_list(&processed_packet_list);
+	TALLOC_FREE(frame);
 	return False;
 }
 
-- 
1.9.1


From 0a9d66eda6e3dd65ff669355081fc60f420968f3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:31:00 -0700
Subject: [PATCH 07/12] s3: nmbd: Change over to using tevent functions from
 direct poll.

This will allow us to eventually remove source3/lib/events.c
dependency and make nmbd purely tevent based.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit b857bf9b3fa3a836647edc40ead92db7b782d367)
---
 source3/nmbd/nmbd_packets.c | 58 +++++++++++++++++++++++++++++----------------
 1 file changed, 38 insertions(+), 20 deletions(-)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index c0c4925..3e94e6e 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1909,14 +1909,16 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	static int listen_number = 0;
 	int num_sockets;
 	int i;
+	int loop_rtn;
+	int timeout_secs;
 
-	int pollrtn;
-	int timeout;
 #ifndef SYNC_DNS
 	int dns_fd;
 	int dns_pollidx = -1;
 #endif
 	struct processed_packet *processed_packet_list = NULL;
+	struct tevent_timer *te = NULL;
+	bool got_timeout = false;
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if ((fds == NULL) || rescan_listen_set) {
@@ -1972,13 +1974,17 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 #endif
 
 	for (i=0; i<num_sockets; i++) {
-		fds[i].events = POLLIN|POLLHUP;
-	}
-
-	/* Process a signal and timer events now... */
-	if (run_events_poll(nmbd_event_context(), 0, NULL, 0)) {
-		TALLOC_FREE(frame);
-		return False;
+		struct tevent_fd *tfd = tevent_add_fd(nmbd_event_context(),
+							frame,
+							attrs[i].fd,
+							TEVENT_FD_READ,
+							nmbd_fd_handler,
+							&attrs[i]);
+		if (tfd == NULL) {
+			TALLOC_FREE(frame);
+			return true;
+		}
+		attrs[i].triggered = false;
 	}
 
 	/*
@@ -1988,28 +1994,40 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	 * the time we are expecting the next netbios packet.
 	 */
 
-	timeout = ((run_election||num_response_packets)
-		   ? 1 : NMBD_SELECT_LOOP) * 1000;
+	if (run_election||num_response_packets) {
+		timeout_secs = 1;
+	} else {
+		timeout_secs = NMBD_SELECT_LOOP;
+	}
 
-	event_add_to_poll_args(nmbd_event_context(), NULL,
-			       &fds, &num_sockets, &timeout);
+	te = tevent_add_timer(nmbd_event_context(),
+				frame,
+				tevent_timeval_current_ofs(timeout_secs, 0),
+				nmbd_timeout_handler,
+				&got_timeout);
+	if (te == NULL) {
+		TALLOC_FREE(frame);
+		return true;
+	}
 
-	pollrtn = poll(fds, num_sockets, timeout);
+	loop_rtn = tevent_loop_once(nmbd_event_context());
 
-	if (run_events_poll(nmbd_event_context(), pollrtn, fds, num_sockets)) {
+	if (loop_rtn == -1) {
 		TALLOC_FREE(frame);
-		return False;
+		return true;
 	}
 
-	if (pollrtn == -1) {
+	if (got_timeout) {
 		TALLOC_FREE(frame);
-		return False;
+		return false;
 	}
 
 #ifndef SYNC_DNS
 	if ((dns_fd != -1) && (dns_pollidx != -1) &&
-	    (fds[dns_pollidx].revents & (POLLIN|POLLHUP|POLLERR))) {
+	    attrs[dns_pollidx].triggered){
 		run_dns_queue(msg);
+		TALLOC_FREE(frame);
+		return false;
 	}
 #endif
 
@@ -2020,7 +2038,7 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 		int client_fd;
 		int client_port;
 
-		if ((fds[i].revents & (POLLIN|POLLHUP|POLLERR)) == 0) {
+		if (!attrs[i].triggered) {
 			continue;
 		}
 
-- 
1.9.1


From 99f98b3b484d34294c09e127d14191f7d069932a Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 12:37:52 -0700
Subject: [PATCH 08/12] s3: nmbd: Final changeover to stock tevent for nmbd.

Removes unused references to fds array used for (removed)
poll call. Renames create_listen_pollfds() to
create_listen_array().

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit 6e8bd13660d7795df429dbf852345124db38ea96)
---
 source3/nmbd/nmbd_packets.c | 46 ++++-----------------------------------------
 1 file changed, 4 insertions(+), 42 deletions(-)

diff --git a/source3/nmbd/nmbd_packets.c b/source3/nmbd/nmbd_packets.c
index 3e94e6e..de5ae1e 100644
--- a/source3/nmbd/nmbd_packets.c
+++ b/source3/nmbd/nmbd_packets.c
@@ -1687,14 +1687,12 @@ struct socket_attributes {
 	bool triggered;
 };
 
-static bool create_listen_pollfds(struct pollfd **pfds,
-				  struct socket_attributes **pattrs,
+static bool create_listen_array(struct socket_attributes **pattrs,
 				  int *pnum_sockets)
 {
 	struct subnet_record *subrec = NULL;
 	int count = 0;
 	int num = 0;
-	struct pollfd *fds;
 	struct socket_attributes *attrs;
 
 	/* The ClientNMB and ClientDGRAM sockets */
@@ -1718,30 +1716,20 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		}
 	}
 
-	fds = talloc_zero_array(NULL, struct pollfd, count);
-	if (fds == NULL) {
-		DEBUG(1, ("create_listen_pollfds: malloc fail for fds. "
-			  "size %d\n", count));
-		return true;
-	}
-
 	attrs = talloc_zero_array(NULL, struct socket_attributes, count);
 	if (attrs == NULL) {
-		DEBUG(1, ("create_listen_pollfds: malloc fail for attrs. "
+		DEBUG(1, ("talloc fail for attrs. "
 			  "size %d\n", count));
-		TALLOC_FREE(fds);
 		return true;
 	}
 
 	num = 0;
 
-	fds[num].fd = ClientNMB;
 	attrs[num].fd = ClientNMB;
 	attrs[num].type = NMB_PACKET;
 	attrs[num].broadcast = false;
 	num += 1;
 
-	fds[num].fd = ClientDGRAM;
 	attrs[num].fd = ClientDGRAM;
 	attrs[num].type = DGRAM_PACKET;
 	attrs[num].broadcast = false;
@@ -1750,7 +1738,6 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 	for (subrec = FIRST_SUBNET; subrec; subrec = NEXT_SUBNET_EXCLUDING_UNICAST(subrec)) {
 
 		if (subrec->nmb_sock != -1) {
-			fds[num].fd = subrec->nmb_sock;
 			attrs[num].fd = subrec->nmb_sock;
 			attrs[num].type = NMB_PACKET;
 			attrs[num].broadcast = false;
@@ -1758,7 +1745,6 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		}
 
 		if (subrec->nmb_bcast != -1) {
-			fds[num].fd = subrec->nmb_bcast;
 			attrs[num].fd = subrec->nmb_bcast;
 			attrs[num].type = NMB_PACKET;
 			attrs[num].broadcast = true;
@@ -1766,7 +1752,6 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		}
 
 		if (subrec->dgram_sock != -1) {
-			fds[num].fd = subrec->dgram_sock;
 			attrs[num].fd = subrec->dgram_sock;
 			attrs[num].type = DGRAM_PACKET;
 			attrs[num].broadcast = false;
@@ -1774,7 +1759,6 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		}
 
 		if (subrec->dgram_bcast != -1) {
-			fds[num].fd = subrec->dgram_bcast;
 			attrs[num].fd = subrec->dgram_bcast;
 			attrs[num].type = DGRAM_PACKET;
 			attrs[num].broadcast = true;
@@ -1782,9 +1766,6 @@ static bool create_listen_pollfds(struct pollfd **pfds,
 		}
 	}
 
-	TALLOC_FREE(*pfds);
-	*pfds = fds;
-
 	TALLOC_FREE(*pattrs);
 	*pattrs = attrs;
 
@@ -1904,7 +1885,6 @@ static void nmbd_fd_handler(struct tevent_context *ev,
 
 bool listen_for_packets(struct messaging_context *msg, bool run_election)
 {
-	static struct pollfd *fds = NULL;
 	static struct socket_attributes *attrs = NULL;
 	static int listen_number = 0;
 	int num_sockets;
@@ -1921,8 +1901,8 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 	bool got_timeout = false;
 	TALLOC_CTX *frame = talloc_stackframe();
 
-	if ((fds == NULL) || rescan_listen_set) {
-		if (create_listen_pollfds(&fds, &attrs, &listen_number)) {
+	if ((attrs == NULL) || rescan_listen_set) {
+		if (create_listen_array(&attrs, &listen_number)) {
 			DEBUG(0,("listen_for_packets: Fatal error. unable to create listen set. Exiting.\n"));
 			TALLOC_FREE(frame);
 			return True;
@@ -1930,38 +1910,20 @@ bool listen_for_packets(struct messaging_context *msg, bool run_election)
 		rescan_listen_set = False;
 	}
 
-	/*
-	 * "fds" can be enlarged by event_add_to_poll_args
-	 * below. Shrink it again to what was given to us by
-	 * create_listen_pollfds.
-	 */
-
-	fds = talloc_realloc(NULL, fds, struct pollfd, listen_number);
-	if (fds == NULL) {
-		TALLOC_FREE(frame);
-		return true;
-	}
 	num_sockets = listen_number;
 
 #ifndef SYNC_DNS
 	dns_fd = asyncdns_fd();
 	if (dns_fd != -1) {
-		fds = talloc_realloc(NULL, fds, struct pollfd, num_sockets+1);
-		if (fds == NULL) {
-			TALLOC_FREE(frame);
-			return true;
-		}
 		attrs = talloc_realloc(NULL,
 					attrs,
 					struct socket_attributes,
 					num_sockets + 1);
 		if (attrs == NULL) {
-			TALLOC_FREE(fds);
 			TALLOC_FREE(frame);
 			return true;
 		}
 		dns_pollidx = num_sockets;
-		fds[num_sockets].fd = dns_fd;
 		attrs[dns_pollidx].fd = dns_fd;
 		/*
 		 * dummy values, we only need
-- 
1.9.1


From 9c5022ebec416cdfaa5c94097fea2eaf9b50d24a Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 19:07:39 -0700
Subject: [PATCH 09/12] s3: winbind: Remove dump_event_list() calls.

If needed we can add this into actual tevent.

Preparing to remove source3/lib/events.c

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit 72785309aa2d1bed7abc6dd7c6475ff0f78411da)
---
 source3/winbindd/winbindd_dual.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/source3/winbindd/winbindd_dual.c b/source3/winbindd/winbindd_dual.c
index 17a89a7..c16b94e 100644
--- a/source3/winbindd/winbindd_dual.c
+++ b/source3/winbindd/winbindd_dual.c
@@ -835,7 +835,7 @@ void winbind_msg_dump_event_list(struct messaging_context *msg_ctx,
 
 	DEBUG(10,("winbind_msg_dump_event_list received\n"));
 
-	dump_event_list(winbind_event_context());
+	DBG_WARNING("dump event list no longer implemented\n");
 
 	for (child = winbindd_children; child != NULL; child = child->next) {
 
@@ -1240,8 +1240,7 @@ static void child_msg_dump_event_list(struct messaging_context *msg,
 				      DATA_BLOB *data)
 {
 	DEBUG(5,("child_msg_dump_event_list received\n"));
-
-	dump_event_list(winbind_event_context());
+	DBG_WARNING("dump_event_list no longer implemented\n");
 }
 
 NTSTATUS winbindd_reinit_after_fork(const struct winbindd_child *myself,
-- 
1.9.1


From 74deb057bffa9ab18d22862b3bbd159c92a849dc Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 19:11:17 -0700
Subject: [PATCH 10/12] s3: server: s3_tevent_context_init() ->
 samba_tevent_context_init()

We can now remove source3/lib/events.c

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(cherry picked from commit fbfea52e1ce8f22d8d020a2bf3aebd1bc69faceb)
---
 source3/lib/server_contexts.c     | 2 +-
 source3/rpc_server/rpc_ncacn_np.c | 8 ++++----
 source3/smbd/process.c            | 4 ++--
 source3/smbd/server.c             | 1 -
 4 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/source3/lib/server_contexts.c b/source3/lib/server_contexts.c
index d49e334..50072e6 100644
--- a/source3/lib/server_contexts.c
+++ b/source3/lib/server_contexts.c
@@ -31,7 +31,7 @@ struct tevent_context *server_event_context(void)
 		 * autofree context, to avoid side effects in forked
 		 * children exiting.
 		 */
-		server_event_ctx = s3_tevent_context_init(NULL);
+		server_event_ctx = samba_tevent_context_init(NULL);
 	}
 	if (!server_event_ctx) {
 		smb_panic("Could not init server's event context");
diff --git a/source3/rpc_server/rpc_ncacn_np.c b/source3/rpc_server/rpc_ncacn_np.c
index f9c73de..083cbbe 100644
--- a/source3/rpc_server/rpc_ncacn_np.c
+++ b/source3/rpc_server/rpc_ncacn_np.c
@@ -708,9 +708,9 @@ NTSTATUS make_external_rpc_pipe(TALLOC_CTX *mem_ctx,
 		goto out;
 	}
 
-	ev_ctx = s3_tevent_context_init(tmp_ctx);
+	ev_ctx = samba_tevent_context_init(tmp_ctx);
 	if (ev_ctx == NULL) {
-		DEBUG(0, ("s3_tevent_context_init failed\n"));
+		DEBUG(0, ("samba_tevent_context_init failed\n"));
 		status = NT_STATUS_NO_MEMORY;
 		goto out;
 	}
@@ -816,9 +816,9 @@ struct np_proxy_state *make_external_rpc_pipe_p(TALLOC_CTX *mem_ctx,
 		goto fail;
 	}
 
-	ev = s3_tevent_context_init(talloc_tos());
+	ev = samba_tevent_context_init(talloc_tos());
 	if (ev == NULL) {
-		DEBUG(0, ("s3_tevent_context_init failed\n"));
+		DEBUG(0, ("samba_tevent_context_init failed\n"));
 		goto fail;
 	}
 
diff --git a/source3/smbd/process.c b/source3/smbd/process.c
index e3c32f9..8f097ec 100644
--- a/source3/smbd/process.c
+++ b/source3/smbd/process.c
@@ -3224,9 +3224,9 @@ static void smbd_echo_loop(struct smbXsrv_connection *xconn,
 	}
 	state->xconn = xconn;
 	state->parent_pipe = parent_pipe;
-	state->ev = s3_tevent_context_init(state);
+	state->ev = samba_tevent_context_init(state);
 	if (state->ev == NULL) {
-		DEBUG(1, ("tevent_context_init failed\n"));
+		DEBUG(1, ("samba_tevent_context_init failed\n"));
 		TALLOC_FREE(state);
 		return;
 	}
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
index 97c0fdc..6d0c664 100644
--- a/source3/smbd/server.c
+++ b/source3/smbd/server.c
@@ -1670,7 +1670,6 @@ extern void build_options(bool screen);
 	 * Initialize the event context. The event context needs to be
 	 * initialized before the messaging context, cause the messaging
 	 * context holds an event context.
-	 * FIXME: This should be s3_tevent_context_init()
 	 */
 	ev_ctx = server_event_context();
 	if (ev_ctx == NULL) {
-- 
1.9.1


From bc6a9794fe2b7fb95423c99174f5e31df9be35ee Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 23 Sep 2016 20:00:33 -0700
Subject: [PATCH 11/12] s3: events. Move events.c to util_event.c

Remove all tevent internal code.

Everything is now stock tevent.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
(similar to commit 4ed790ebbf474c4e4ef9b4f0f3aeca65118796df)
---
 source3/include/event.h      |  42 ----
 source3/include/includes.h   |   4 +-
 source3/include/util_event.h |  28 +++
 source3/lib/events.c         | 486 -------------------------------------------
 source3/lib/util_event.c     | 101 +++++++++
 source3/wscript_build        |   2 +-
 6 files changed, 132 insertions(+), 531 deletions(-)
 delete mode 100644 source3/include/event.h
 create mode 100644 source3/include/util_event.h
 delete mode 100644 source3/lib/events.c
 create mode 100644 source3/lib/util_event.c

diff --git a/source3/include/event.h b/source3/include/event.h
deleted file mode 100644
index 108026e..0000000
--- a/source3/include/event.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-   Unix SMB/CIFS implementation.
-   event handling
-   Copyright (C) Andrew Tridgell 1992-1998
-   Copyright (C) Volker Lendecke 2005-2007
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <tevent.h>
-
-/* The following definitions come from lib/events.c  */
-struct pollfd;
-struct timeval *get_timed_events_timeout(struct tevent_context *event_ctx,
-					 struct timeval *to_ret);
-void dump_event_list(struct tevent_context *event_ctx);
-struct tevent_context *s3_tevent_context_init(TALLOC_CTX *mem_ctx);
-
-bool event_add_to_poll_args(struct tevent_context *ev, TALLOC_CTX *mem_ctx,
-			    struct pollfd **pfds, int *num_pfds,
-			    int *ptimeout);
-bool run_events_poll(struct tevent_context *ev, int pollrtn,
-		     struct pollfd *pfds, int num_pfds);
-
-struct idle_event *event_add_idle(struct tevent_context *event_ctx,
-				  TALLOC_CTX *mem_ctx,
-				  struct timeval interval,
-				  const char *name,
-				  bool (*handler)(const struct timeval *now,
-						  void *private_data),
-				  void *private_data);
diff --git a/source3/include/includes.h b/source3/include/includes.h
index 81bba40..234a564 100644
--- a/source3/include/includes.h
+++ b/source3/include/includes.h
@@ -310,8 +310,8 @@ typedef char fstring[FSTRING_LEN];
 #include "../lib/util/dlinklist.h"
 
 #include <talloc.h>
-
-#include "event.h"
+#include <tevent.h>
+#include "util_event.h"
 
 #include "../lib/util/data_blob.h"
 #include "../lib/util/time.h"
diff --git a/source3/include/util_event.h b/source3/include/util_event.h
new file mode 100644
index 0000000..df608a1
--- /dev/null
+++ b/source3/include/util_event.h
@@ -0,0 +1,28 @@
+/*
+   Unix SMB/CIFS implementation.
+   event handling
+   Copyright (C) Andrew Tridgell 1992-1998
+   Copyright (C) Volker Lendecke 2005-2007
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* The following definitions come from lib/util_event.c  */
+struct idle_event *event_add_idle(struct tevent_context *event_ctx,
+				  TALLOC_CTX *mem_ctx,
+				  struct timeval interval,
+				  const char *name,
+				  bool (*handler)(const struct timeval *now,
+						  void *private_data),
+				  void *private_data);
diff --git a/source3/lib/events.c b/source3/lib/events.c
deleted file mode 100644
index 2e862ca..0000000
--- a/source3/lib/events.c
+++ /dev/null
@@ -1,486 +0,0 @@
-/*
-   Unix SMB/CIFS implementation.
-   Timed event library.
-   Copyright (C) Andrew Tridgell 1992-1998
-   Copyright (C) Volker Lendecke 2005-2007
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "includes.h"
-#include "lib/tevent/tevent_internal.h"
-#include "../lib/util/select.h"
-#include "system/select.h"
-
-struct tevent_poll_private {
-	/*
-	 * Index from file descriptor into the pollfd array
-	 */
-	int *pollfd_idx;
-
-	/*
-	 * Cache for s3_event_loop_once to avoid reallocs
-	 */
-	struct pollfd *pfds;
-};
-
-static struct tevent_poll_private *tevent_get_poll_private(
-	struct tevent_context *ev)
-{
-	struct tevent_poll_private *state;
-
-	state = (struct tevent_poll_private *)ev->additional_data;
-	if (state == NULL) {
-		state = talloc_zero(ev, struct tevent_poll_private);
-		ev->additional_data = (void *)state;
-		if (state == NULL) {
-			DEBUG(10, ("talloc failed\n"));
-		}
-	}
-	return state;
-}
-
-static void count_fds(struct tevent_context *ev,
-		      int *pnum_fds, int *pmax_fd)
-{
-	struct tevent_fd *fde;
-	int num_fds = 0;
-	int max_fd = 0;
-
-	for (fde = ev->fd_events; fde != NULL; fde = fde->next) {
-		if (fde->flags & (TEVENT_FD_READ|TEVENT_FD_WRITE)) {
-			num_fds += 1;
-			if (fde->fd > max_fd) {
-				max_fd = fde->fd;
-			}
-		}
-	}
-	*pnum_fds = num_fds;
-	*pmax_fd = max_fd;
-}
-
-bool event_add_to_poll_args(struct tevent_context *ev, TALLOC_CTX *mem_ctx,
-			    struct pollfd **pfds, int *pnum_pfds,
-			    int *ptimeout)
-{
-	struct tevent_poll_private *state;
-	struct tevent_fd *fde;
-	int i, num_fds, max_fd, num_pollfds, idx_len;
-	struct pollfd *fds;
-	struct timeval now, diff;
-	int timeout;
-
-	state = tevent_get_poll_private(ev);
-	if (state == NULL) {
-		return false;
-	}
-	count_fds(ev, &num_fds, &max_fd);
-
-	idx_len = max_fd+1;
-
-	if (talloc_array_length(state->pollfd_idx) < idx_len) {
-		state->pollfd_idx = talloc_realloc(
-			state, state->pollfd_idx, int, idx_len);
-		if (state->pollfd_idx == NULL) {
-			DEBUG(10, ("talloc_realloc failed\n"));
-			return false;
-		}
-	}
-
-	fds = *pfds;
-	num_pollfds = *pnum_pfds;
-
-	if (talloc_array_length(fds) < num_pollfds + num_fds) {
-		fds = talloc_realloc(mem_ctx, fds, struct pollfd,
-					   num_pollfds + num_fds);
-		if (fds == NULL) {
-			DEBUG(10, ("talloc_realloc failed\n"));
-			return false;
-		}
-	}
-
-	memset(&fds[num_pollfds], 0, sizeof(struct pollfd) * num_fds);
-
-	/*
-	 * This needs tuning. We need to cope with multiple fde's for a file
-	 * descriptor. The problem is that we need to re-use pollfd_idx across
-	 * calls for efficiency. One way would be a direct bitmask that might
-	 * be initialized quicker, but our bitmap_init implementation is
-	 * pretty heavy-weight as well.
-	 */
-	for (i=0; i<idx_len; i++) {
-		state->pollfd_idx[i] = -1;
-	}
-
-	for (fde = ev->fd_events; fde; fde = fde->next) {
-		struct pollfd *pfd;
-
-		if ((fde->flags & (TEVENT_FD_READ|TEVENT_FD_WRITE)) == 0) {
-			continue;
-		}
-
-		if (state->pollfd_idx[fde->fd] == -1) {
-			/*
-			 * We haven't seen this fd yet. Allocate a new pollfd.
-			 */
-			state->pollfd_idx[fde->fd] = num_pollfds;
-			pfd = &fds[num_pollfds];
-			num_pollfds += 1;
-		} else {
-			/*
-			 * We have already seen this fd. OR in the flags.
-			 */
-			pfd = &fds[state->pollfd_idx[fde->fd]];
-		}
-
-		pfd->fd = fde->fd;
-
-		if (fde->flags & TEVENT_FD_READ) {
-			pfd->events |= (POLLIN|POLLHUP);
-		}
-		if (fde->flags & TEVENT_FD_WRITE) {
-			pfd->events |= POLLOUT;
-		}
-	}
-	*pfds = fds;
-	*pnum_pfds = num_pollfds;
-
-	if (ev->immediate_events != NULL) {
-		*ptimeout = 0;
-		return true;
-	}
-	if (ev->timer_events == NULL) {
-		*ptimeout = MIN(*ptimeout, INT_MAX);
-		return true;
-	}
-
-	now = timeval_current();
-	diff = timeval_until(&now, &ev->timer_events->next_event);
-	timeout = timeval_to_msec(diff);
-
-	if (timeout < *ptimeout) {
-		*ptimeout = timeout;
-	}
-
-	return true;
-}
-
-bool run_events_poll(struct tevent_context *ev, int pollrtn,
-		     struct pollfd *pfds, int num_pfds)
-{
-	struct tevent_poll_private *state;
-	int *pollfd_idx;
-	struct tevent_fd *fde;
-
-	if (ev->signal_events &&
-	    tevent_common_check_signal(ev)) {
-		return true;
-	}
-
-	if (ev->immediate_events &&
-	    tevent_common_loop_immediate(ev)) {
-		return true;
-	}
-
-	if (pollrtn <= 0) {
-		struct timeval tval;
-
-		tval = tevent_common_loop_timer_delay(ev);
-		if (tevent_timeval_is_zero(&tval)) {
-			return true;
-		}
-
-		/*
-		 * No fd ready
-		 */
-		return false;
-	}
-
-	state = (struct tevent_poll_private *)ev->additional_data;
-	pollfd_idx = state->pollfd_idx;
-
-	for (fde = ev->fd_events; fde; fde = fde->next) {
-		struct pollfd *pfd;
-		uint16_t flags = 0;
-
-		if ((fde->flags & (TEVENT_FD_READ|TEVENT_FD_WRITE)) == 0) {
-			continue;
-		}
-
-		if (pollfd_idx[fde->fd] >= num_pfds) {
-			DEBUG(1, ("internal error: pollfd_idx[fde->fd] (%d) "
-				  ">= num_pfds (%d)\n", pollfd_idx[fde->fd],
-				  num_pfds));
-			return false;
-		}
-		pfd = &pfds[pollfd_idx[fde->fd]];
-
-		if (pfd->fd != fde->fd) {
-			DEBUG(1, ("internal error: pfd->fd (%d) "
-				  "!= fde->fd (%d)\n", pollfd_idx[fde->fd],
-                                  num_pfds));
-			return false;
-		}
-
-		if (pfd->revents & (POLLHUP|POLLERR)) {
-			/* If we only wait for TEVENT_FD_WRITE, we
-			   should not tell the event handler about it,
-			   and remove the writable flag, as we only
-			   report errors when waiting for read events
-			   to match the select behavior. */
-			if (!(fde->flags & TEVENT_FD_READ)) {
-				TEVENT_FD_NOT_WRITEABLE(fde);
-				continue;
-			}
-			flags |= TEVENT_FD_READ;
-		}
-
-		if (pfd->revents & POLLIN) {
-			flags |= TEVENT_FD_READ;
-		}
-		if (pfd->revents & POLLOUT) {
-			flags |= TEVENT_FD_WRITE;
-		}
-		if (flags & fde->flags) {
-			DLIST_DEMOTE(ev->fd_events, fde);
-			fde->handler(ev, fde, flags, fde->private_data);
-			return true;
-		}
-	}
-
-	return false;
-}
-
-struct timeval *get_timed_events_timeout(struct tevent_context *ev,
-					 struct timeval *to_ret)
-{
-	struct timeval now;
-
-	if ((ev->timer_events == NULL) && (ev->immediate_events == NULL)) {
-		return NULL;
-	}
-	if (ev->immediate_events != NULL) {
-		*to_ret = timeval_zero();
-		return to_ret;
-	}
-
-	now = timeval_current();
-	*to_ret = timeval_until(&now, &ev->timer_events->next_event);
-
-	DEBUG(10, ("timed_events_timeout: %d/%d\n", (int)to_ret->tv_sec,
-		(int)to_ret->tv_usec));
-
-	return to_ret;
-}
-
-static int s3_event_loop_once(struct tevent_context *ev, const char *location)
-{
-	struct tevent_poll_private *state;
-	int timeout;
-	int num_pfds;
-	int ret;
-	int poll_errno;
-
-	timeout = INT_MAX;
-
-	state = tevent_get_poll_private(ev);
-	if (state == NULL) {
-		errno = ENOMEM;
-		return -1;
-	}
-
-	if (run_events_poll(ev, 0, NULL, 0)) {
-		return 0;
-	}
-
-	num_pfds = 0;
-	if (!event_add_to_poll_args(ev, state,
-				    &state->pfds, &num_pfds, &timeout)) {
-		return -1;
-	}
-
-	tevent_trace_point_callback(ev, TEVENT_TRACE_BEFORE_WAIT);
-	ret = poll(state->pfds, num_pfds, timeout);
-	poll_errno = errno;
-	tevent_trace_point_callback(ev, TEVENT_TRACE_AFTER_WAIT);
-	errno = poll_errno;
-
-	if (ret == -1 && errno != EINTR) {
-		tevent_debug(ev, TEVENT_DEBUG_FATAL,
-			     "poll() failed: %d:%s\n",
-			     errno, strerror(errno));
-		return -1;
-	}
-
-	run_events_poll(ev, ret, state->pfds, num_pfds);
-	return 0;
-}
-
-static int s3_event_context_init(struct tevent_context *ev)
-{
-	return 0;
-}
-
-void dump_event_list(struct tevent_context *ev)
-{
-	struct tevent_timer *te;
-	struct tevent_fd *fe;
-	struct timeval evt, now;
-
-	if (!ev) {
-		return;
-	}
-
-	now = timeval_current();
-
-	DEBUG(10,("dump_event_list:\n"));
-
-	for (te = ev->timer_events; te; te = te->next) {
-
-		evt = timeval_until(&now, &te->next_event);
-
-		DEBUGADD(10,("Timed Event \"%s\" %p handled in %d seconds (at %s)\n",
-			   te->handler_name,
-			   te,
-			   (int)evt.tv_sec,
-			   http_timestring(talloc_tos(), te->next_event.tv_sec)));
-	}
-
-	for (fe = ev->fd_events; fe; fe = fe->next) {
-
-		DEBUGADD(10,("FD Event %d %p, flags: 0x%04x\n",
-			   fe->fd,
-			   fe,
-			   fe->flags));
-	}
-}
-
-static const struct tevent_ops s3_event_ops = {
-	.context_init		= s3_event_context_init,
-	.add_fd			= tevent_common_add_fd,
-	.set_fd_close_fn	= tevent_common_fd_set_close_fn,
-	.get_fd_flags		= tevent_common_fd_get_flags,
-	.set_fd_flags		= tevent_common_fd_set_flags,
-	.add_timer		= tevent_common_add_timer,
-	.schedule_immediate	= tevent_common_schedule_immediate,
-	.add_signal		= tevent_common_add_signal,
-	.loop_once		= s3_event_loop_once,
-	.loop_wait		= tevent_common_loop_wait,
-};
-
-static bool s3_tevent_init(void)
-{
-	static bool initialized;
-	if (initialized) {
-		return true;
-	}
-	initialized = tevent_register_backend("s3", &s3_event_ops);
-	tevent_set_default_backend("s3");
-	return initialized;
-}
-
-struct tevent_context *s3_tevent_context_init(TALLOC_CTX *mem_ctx)
-{
-	struct tevent_context *ev;
-
-	s3_tevent_init();
-
-	ev = tevent_context_init_byname(mem_ctx, "s3");
-	if (ev) {
-		samba_tevent_set_debug(ev, "s3_tevent");
-	}
-
-	return ev;
-}
-
-struct idle_event {
-	struct tevent_timer *te;
-	struct timeval interval;
-	char *name;
-	bool (*handler)(const struct timeval *now, void *private_data);
-	void *private_data;
-};
-
-static void smbd_idle_event_handler(struct tevent_context *ctx,
-				    struct tevent_timer *te,
-				    struct timeval now,
-				    void *private_data)
-{
-	struct idle_event *event =
-		talloc_get_type_abort(private_data, struct idle_event);
-
-	TALLOC_FREE(event->te);
-
-	DEBUG(10,("smbd_idle_event_handler: %s %p called\n",
-		  event->name, event->te));
-
-	if (!event->handler(&now, event->private_data)) {
-		DEBUG(10,("smbd_idle_event_handler: %s %p stopped\n",
-			  event->name, event->te));
-		/* Don't repeat, delete ourselves */
-		TALLOC_FREE(event);
-		return;
-	}
-
-	DEBUG(10,("smbd_idle_event_handler: %s %p rescheduled\n",
-		  event->name, event->te));
-
-	event->te = tevent_add_timer(ctx, event,
-				     timeval_sum(&now, &event->interval),
-				     smbd_idle_event_handler, event);
-
-	/* We can't do much but fail here. */
-	SMB_ASSERT(event->te != NULL);
-}
-
-struct idle_event *event_add_idle(struct tevent_context *event_ctx,
-				  TALLOC_CTX *mem_ctx,
-				  struct timeval interval,
-				  const char *name,
-				  bool (*handler)(const struct timeval *now,
-						  void *private_data),
-				  void *private_data)
-{
-	struct idle_event *result;
-	struct timeval now = timeval_current();
-
-	result = talloc(mem_ctx, struct idle_event);
-	if (result == NULL) {
-		DEBUG(0, ("talloc failed\n"));
-		return NULL;
-	}
-
-	result->interval = interval;
-	result->handler = handler;
-	result->private_data = private_data;
-
-	if (!(result->name = talloc_asprintf(result, "idle_evt(%s)", name))) {
-		DEBUG(0, ("talloc failed\n"));
-		TALLOC_FREE(result);
-		return NULL;
-	}
-
-	result->te = tevent_add_timer(event_ctx, result,
-				      timeval_sum(&now, &interval),
-				      smbd_idle_event_handler, result);
-	if (result->te == NULL) {
-		DEBUG(0, ("event_add_timed failed\n"));
-		TALLOC_FREE(result);
-		return NULL;
-	}
-
-	DEBUG(10,("event_add_idle: %s %p\n", result->name, result->te));
-	return result;
-}
-
diff --git a/source3/lib/util_event.c b/source3/lib/util_event.c
new file mode 100644
index 0000000..4ca2840
--- /dev/null
+++ b/source3/lib/util_event.c
@@ -0,0 +1,101 @@
+/*
+   Unix SMB/CIFS implementation.
+   Timed event library.
+   Copyright (C) Andrew Tridgell 1992-1998
+   Copyright (C) Volker Lendecke 2005-2007
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+
+struct idle_event {
+	struct tevent_timer *te;
+	struct timeval interval;
+	char *name;
+	bool (*handler)(const struct timeval *now, void *private_data);
+	void *private_data;
+};
+
+static void smbd_idle_event_handler(struct tevent_context *ctx,
+				    struct tevent_timer *te,
+				    struct timeval now,
+				    void *private_data)
+{
+	struct idle_event *event =
+		talloc_get_type_abort(private_data, struct idle_event);
+
+	TALLOC_FREE(event->te);
+
+	DEBUG(10,("smbd_idle_event_handler: %s %p called\n",
+		  event->name, event->te));
+
+	if (!event->handler(&now, event->private_data)) {
+		DEBUG(10,("smbd_idle_event_handler: %s %p stopped\n",
+			  event->name, event->te));
+		/* Don't repeat, delete ourselves */
+		TALLOC_FREE(event);
+		return;
+	}
+
+	DEBUG(10,("smbd_idle_event_handler: %s %p rescheduled\n",
+		  event->name, event->te));
+
+	event->te = tevent_add_timer(ctx, event,
+				     timeval_sum(&now, &event->interval),
+				     smbd_idle_event_handler, event);
+
+	/* We can't do much but fail here. */
+	SMB_ASSERT(event->te != NULL);
+}
+
+struct idle_event *event_add_idle(struct tevent_context *event_ctx,
+				  TALLOC_CTX *mem_ctx,
+				  struct timeval interval,
+				  const char *name,
+				  bool (*handler)(const struct timeval *now,
+						  void *private_data),
+				  void *private_data)
+{
+	struct idle_event *result;
+	struct timeval now = timeval_current();
+
+	result = talloc(mem_ctx, struct idle_event);
+	if (result == NULL) {
+		DEBUG(0, ("talloc failed\n"));
+		return NULL;
+	}
+
+	result->interval = interval;
+	result->handler = handler;
+	result->private_data = private_data;
+
+	if (!(result->name = talloc_asprintf(result, "idle_evt(%s)", name))) {
+		DEBUG(0, ("talloc failed\n"));
+		TALLOC_FREE(result);
+		return NULL;
+	}
+
+	result->te = tevent_add_timer(event_ctx, result,
+				      timeval_sum(&now, &interval),
+				      smbd_idle_event_handler, result);
+	if (result->te == NULL) {
+		DEBUG(0, ("event_add_timed failed\n"));
+		TALLOC_FREE(result);
+		return NULL;
+	}
+
+	DEBUG(10,("event_add_idle: %s %p\n", result->name, result->te));
+	return result;
+}
diff --git a/source3/wscript_build b/source3/wscript_build
index 8546e8d..d19b583 100755
--- a/source3/wscript_build
+++ b/source3/wscript_build
@@ -333,7 +333,7 @@ bld.SAMBA3_SUBSYSTEM('samba3core',
                    lib/dmallocmsg.c
                    intl/lang_tdb.c
                    lib/gencache.c
-                   lib/events.c
+                   lib/util_event.c
                    lib/server_contexts.c
                    lib/server_prefork.c
                    lib/server_prefork_util.c
-- 
1.9.1


From cf8c45874d968494b622e7b0c22ada4d054c5c05 Mon Sep 17 00:00:00 2001
From: Volker Lendecke <vl@samba.org>
Date: Sat, 24 Sep 2016 10:45:13 -0700
Subject: [PATCH 12/12] glusterfs: Avoid tevent_internal.h
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Günther confirmed it still compiles :-)

Bug: https://bugzilla.samba.org/show_bug.cgi?id=12283
Signed-off-by: Volker Lendecke <vl@samba.org>
Reviewed-by: Günther Deschner <gd@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Sat Sep 24 23:41:56 CEST 2016 on sn-devel-144

(cherry picked from commit c60ea2c17814f9f7b55514e0d0a553accaa54b15)
---
 source3/modules/vfs_glusterfs.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/source3/modules/vfs_glusterfs.c b/source3/modules/vfs_glusterfs.c
index fbcaf5c..a467235 100644
--- a/source3/modules/vfs_glusterfs.c
+++ b/source3/modules/vfs_glusterfs.c
@@ -41,7 +41,6 @@
 #include "api/glfs.h"
 #include "lib/util/dlinklist.h"
 #include "lib/util/tevent_unix.h"
-#include "lib/tevent/tevent_internal.h"
 #include "smbd/globals.h"
 #include "lib/util/sys_rw.h"
 #include "smbprofile.h"
-- 
1.9.1

