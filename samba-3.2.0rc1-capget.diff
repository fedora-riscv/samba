 source/include/smb.h       |    3 +-
 source/lib/system.c        |    5 ++++
 source/smbd/oplock_linux.c |   48 +------------------------------------------
 3 files changed, 9 insertions(+), 47 deletions(-)

diff --git a/source/include/smb.h b/source/include/smb.h
index d6b026d..38d9b7b 100644
--- a/source/include/smb.h
+++ b/source/include/smb.h
@@ -1703,7 +1703,8 @@ minimum length == 18.
 
 enum smbd_capability {
     KERNEL_OPLOCK_CAPABILITY,
-    DMAPI_ACCESS_CAPABILITY
+    DMAPI_ACCESS_CAPABILITY,
+    LEASE_CAPABILITY
 };
 
 /* if a kernel does support oplocks then a structure of the following
diff --git a/source/lib/system.c b/source/lib/system.c
index fa50955..eabb6d6 100644
--- a/source/lib/system.c
+++ b/source/lib/system.c
@@ -733,6 +733,11 @@ static bool set_process_capability(enum smbd_capability capability,
 			cap_vals[num_cap_vals++] = CAP_MKNOD;
 #endif
 			break;
+		case LEASE_CAPABILITY:
+#ifdef CAP_LEASE
+			cap_vals[num_cap_vals++] = CAP_LEASE;
+#endif
+			break;
 	}
 
 	SMB_ASSERT(num_cap_vals <= ARRAY_SIZE(cap_vals));
diff --git a/source/smbd/oplock_linux.c b/source/smbd/oplock_linux.c
index fa7cb42..08df228 100644
--- a/source/smbd/oplock_linux.c
+++ b/source/smbd/oplock_linux.c
@@ -22,22 +22,6 @@
 
 #if HAVE_KERNEL_OPLOCKS_LINUX
 
-/* these can be removed when they are in glibc headers */
-struct  cap_user_header {
-	uint32 version;
-	int pid;
-} header;
-struct cap_user_data {
-	uint32 effective;
-	uint32 permitted;
-	uint32 inheritable;
-} data;
-
-extern int capget(struct cap_user_header * hdrp,
-		  struct cap_user_data * datap);
-extern int capset(struct cap_user_header * hdrp,
-		  const struct cap_user_data * datap);
-
 static SIG_ATOMIC_T signals_received;
 #define FD_PENDING_SIZE 100
 static SIG_ATOMIC_T fd_pending_array[FD_PENDING_SIZE];
@@ -75,40 +59,12 @@ static void signal_handler(int sig, siginfo_t *info, void *unused)
 	sys_select_signal(RT_SIGNAL_LEASE);
 }
 
-/****************************************************************************
- Try to gain a linux capability.
-****************************************************************************/
-
-static void set_capability(unsigned capability)
-{
-#ifndef _LINUX_CAPABILITY_VERSION
-#define _LINUX_CAPABILITY_VERSION 0x19980330
-#endif
-	header.version = _LINUX_CAPABILITY_VERSION;
-	header.pid = 0;
-
-	if (capget(&header, &data) == -1) {
-		DEBUG(3,("Unable to get kernel capabilities (%s)\n",
-			 strerror(errno)));
-		return;
-	}
-
-	if (0 == (data.effective & (1<<capability))) {
-		data.effective |= (1<<capability);
-
-		if (capset(&header, &data) == -1) {
-			DEBUG(3,("Unable to set %d capability (%s)\n", 
-				 capability, strerror(errno)));
-		}
-	}
-}
-
 /*
  * public function to get linux lease capability. Needed by some VFS modules (eg. gpfs.c)
  */
 void linux_set_lease_capability(void)
 {
-	set_capability(CAP_LEASE);
+	set_effective_capability(LEASE_CAPABILITY);
 }
 
 /* 
@@ -136,7 +92,7 @@ int linux_setlease(int fd, int leasetype)
 
 	ret = fcntl(fd, F_SETLEASE, leasetype);
 	if (ret == -1 && errno == EACCES) {
-		set_capability(CAP_LEASE);
+		set_effective_capability(LEASE_CAPABILITY);
 		ret = fcntl(fd, F_SETLEASE, leasetype);
 	}
 
